## [基础网络概念](http://linux.vbird.org/linux_server/0110network_basic.php#whatisnetwork_comps)

### 2.1 网络是个什么玩意

那么多的操作系统要如何进行网络沟通？那就得要制定共同遵守的标准才行。这个标准是由国际组织规范的，你的系统里面只要提供符合该标准的程序代码，那你就能够通过这个标准和其他系统进行沟通。所以，网络是跨平台的。

#### 2.1.1 什么是网络

网络就是几部电脑主机或者网络打印机之类的周边设备，通过网线或者无线网络的技术，将这些主机和设备连接起来，使得数据可以通过网络媒体（网线以及其他网卡等硬件）来传输的一种方式。

##### 各自为政的“网络硬件和软件”技术发展：Ethernet & Token-Ring

Ethernet由施乐公司研发，Token-Ring由IBM研发。

##### 以软件技术将硬件整合： ARPANET & TCP/IP

为了解决上述的网络硬件整合功能，所以在1960年代美国就开始研究一个<u>可以在这些不同的网络硬件上运行的软件技术，使得不同公司的电脑或数据可以通过这个软件来达成数据传输。</u>ARPANET就是TCP/IP的雏形了。DARPA在1980年正式推出TCP/IP技术后，将TCP/IP植入BSD Unix系统内，这种连接网络的技术也被称之为Internet。

##### 没有任何王法的网际网络： Internet

Internet就是使用TCP/IP的网络技术所串联起来的一个网络世界。

##### 软硬件标准制定的成功带来的影响：IEEE标准规范

以太网络（Ethernet）和Internet是最成功的的。这二者都被标准所支持。

==以太网络：IEEE 802.3标准（这是一个硬件标准）==

除了硬件之外，TCP/IP这个Internet的通讯协议也是有标准的，这些标准大部分都以RFC（Request For Comments）的形式发布标准文件。通过这些文件的辅助，任何人只要会写程序的话，就有可能发展出自己的TCP/IP软件，并且连接上Internet。早期的Linux为了要连上Internet，Linux团队就自己编写出TCP/IP的代码，通过这些基础文件的标准依据。举例来说RFC 1122这个建议文件就指出一些可以连接到 Internet 的主机应该要注意的相关协议与基本要求，让想要编写连接程序的设计师可以有一个指引的标准方向。

#### 2.1.2 电脑网络组成元件

##### 节点（node）

节点主要是具有网络地址（IP）的设备称呼，因此一般PC，Linux服务器，ADSL数据机和网络打印机等都可以成为一个node。==集线器（hub）不是节点，因为它不具有IP。==

##### 服务器主机（server）

以网络连接的方向来说，提供数据以回应给用户主机，都可以被称为是一台服务器。

##### 工作站（workstation）或用户端（client）

任何可以在电脑网络输入的设备都可以是工作站，如果以连接发起的方向来说，主动发起连接去请求数据的，就可以称为是客户端（client）。

##### 网卡（Network Interface Card， NIC）

内建或者外插在主机上的一个设备，主要提供网络连接的卡片，目前大都使用具有RJ-45接头的以太网卡。一般node上都有一个以上的网卡，以达成网络连接的功能。

##### 网络界面

利用软件设计出来的网络界面，主要提供网址（IP）的任务。一张网卡至少可以搭配一个以上的网络界面，而每部主机内部其实也都有一个内部的网络界面，那就是loopback（lo）这个回环地址。

##### 网络形态或拓扑（topology）

各个节点在网络上的连接方式，一般讲的是物理连接方式。

##### 网关（route）或通讯闸（gateway）

具有两个以上的网络接口，可以连接两个以上不同网段的设备，例如IP分享器就是一个常见的网关设备。<u>==ADSL不算是网关==，因为调制解调器通常视为一个在主机内的网卡设备，我们可以在一般PC上通过拨号软件，将调制解调器模拟成为一张实体网卡（ppp），因此不太能算是网卡设备</u>

#### 2.1.3 电脑网络区域范围

由于各个节点的距离不同，连接的线材和方式也有所差异，由于线材的差异也导致网速的不同，让网络的应用方向也不一样。根据这些差别，早期我们习惯将网络的大小范围定义如下：

* 局域网（Local Area Network， LAN）
* 广域网（Wide Area Network， WAN）

除了这两个之外，还有MAN（Metropolitan Area Network）

目前，可以用网速作为一个网络区域范围的评估。

#### 2.1.4 电脑网络通讯协议： OSI七层协议

各个节点之间是如何沟通信息的？=> 通过标准的通讯协议。

> 为什么要采用分层协议？
>
> ​		整个网络连接的过程相当复杂，包括硬件、软件数据包和应用程序的互相连结等等，如果想要写一个将连网全部功能都串联在一起的程序，那么当某个小环节出现问题时，整个程序都需要改写，非常麻烦。所以我们可以将整个网络连接过程分成数个层级，每个层级都有特别的独立功能，而且每个层级的代码可以独立编写，因为每个层级之间的功能并不会互相干扰。如此一来，当某个小环节出现问题时，只要将该层级的代码重新编写即可。所以程序编写也容易，整个网络概念也就更清晰。

那就是你常听到的==OSI七层协议（Open System Interconnection）==

根据定义，越接近硬件的层级为底层（layer 1），越金姐应用程序的则是高层（layer 7）.不管是接收端还是发送端，==每个层级都只认识对方的同一层级的数据==。

上层的包裹放入下层的数据中，而数据前面则是这个数据的表头。其中比较特殊的是第二层，因为第二层（数据链路层）主要是位于软件数据包（packet）以及硬件数据帧（frame）中间的一个阶层，它必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个阶层又分为两个子层在处理相对应的数据。因为比较特殊，所以第==二层的数据格式尾部还会出现一个校验码==。

每一层负责的任务：

|    分层    |                           负责内容                           |
| :--------: | :----------------------------------------------------------: |
|   实体层   | 由于网络媒体只能传送0和1这样的内容，因此实体层必须定义所使用的的媒体设备的电压和信号等，同时还必须了解数据帧转换成0/1的编码方式，最后连接实体媒体并传送/接收0/1 |
| 数据链路层 | 这一层是比较特殊的一个阶层，因为底下是实体的定义，而上层是软件封装的定义。因为第二层又分两个子层在进行数据的转换动作。<u>在偏硬件的部分，主要负责的是MAC（Media Access Control），我们称这个数据包为MAC帧，</u>MAC是网络媒体所能处理的主要数据包，这也是最终被实体层编码成01的数据。MAC必须经由通讯协议来取得媒体的使用权。目前最常使用的是IEEE 802.3的以太网协议。  至于<u>偏软件的部分则是由逻辑链路层（logical link control, LLC）所控制，主要在多任务处理来自上层的数据包资料并转成MAC的格式</u>，负责的工作包括信息交换，流量控制，失误问题的处理等等。 |
|   网络层   | 这一层是我们最感兴趣的，因为我们提及的IP就是在这一层定义的。同时也定义出电脑之间的连接建立、终止与维持等等，数据包的传输路径选择等等，因此这个层级当中最重要的除了IP之外，就是数据包等否到达目的地的路由概念了。 |
|   传输层   | 这一层定义了发送端和接收端的连接技术（如TCP，UDP），同时包括该技术的数据包格式，数据包的传送，流程的控制，传输过程的检测检查和失败重传等等，以确保各个数据包可以正确无误的到达目的端 |
|   会话层   | 在这个层级中主要定义了两个地址之间的连线通道之连接和挂断，此外，也可建立应用程序的对话、提供其他加强型服务如网络管理，签到签退，对话控制等等。**如果说传输层是在判断数据包是否可以正确的到达目标，那么会话层则是在确定网路服务建立连接的确认。** |
|   表现层   | 我们在应用程序上所制作出来的数据格式不一定符合网络传输的标准编码格式，所以在这个层级当中，主要的动作就是：将来自本地端应用程序的数据格式转换（或者是重新编码）称为网络的标准格式，然后再交给底下的传输层等协议来进行处理。所以<u>在这个层级上主要定义的是网络服务（或程序）之间的数据格式的转换，包括数据的加密解密也是在这个层面上处理</u> |
|   应用层   | 应用层本身并不属于应用程序所有，而是在定义应用程序如何进入此层的沟通界面，以将数据接收或传送给应用程序，最终展示给使用者。 |

#### 2.1.5 电脑网络通讯协议： TCP/IP

TCP/IP简化为四层，两者的相关性如下：

TCP将<u>应用层、表示层、会话层</u>整合成一个<u>应用层</u>，在应用层上可以运行的协议有HTTP、SMTP、DNS等。

<u>传输层</u>没有变，不过根据传输的可靠性又将数据包格式分为连接导向的TCP和非连接导向的UDP数据包格式。

<u>网络层</u>：也没有改变，主要内容是提供了IP数据包，并可选择最佳路由来到达目标IP位置。

<u>数据链路层</u>和<u>实体层</u>整合为一个<u>链路层</u>，包括定义硬件信号，数据帧转编码等，因此主要与硬件（不管是局域网还是广域网）有关。

TCP/IP是如何运行的：

0. 应用程序阶段：打开浏览器，在浏览器里输入网址，摁下回车，此时网址和相关数据会被浏览器包成一个数据，并向下传递给TCP/IP的应用层
1. 应用层：由应用层提供的HTTP通讯协议，将来自浏览器的数据包起来，并给予一个应用层表头，再向传输层丢去
2. 传输层：由于HTTP为可靠连接，因此将该数据包丢入TCP数据包内，并给予一个TCP数据包的表头，向网络层丢去
3. 网络层：将TCP包丢进IP数据包内，再给予一个IP表头（主要就是来源和目的IP），向链路层丢去
4. 链路层：如果使用以太网络，此时IP会根据CSMA/CD的标准，包裹到MAC数据帧中，并给予MAC表头，转成10后，利用传输介质传送到远程主机上。

网络媒体一次传输的数据量是有限的，因此如果要被传输的数据太大时，我们在分层的数据包中，就得要将数据先拆开放到不同的数据包中，再给数据包一个序号，好让目的端的主机能够藉由这些序号再重新将数据整合回来。

> 一般来说，因为应用程序和开发工程师比较有关系，而网络层以下的数据则主要是由操作系统提供的，因此，我们又将TCP/IP当中的应用层视为使用者层，而底下的三层才是我们主要谈到的网络基础。

### 2.2 TCP/IP的链路层相关协议

TCP/IP最底层的链路层主要和硬件比较有关系，因此底下我们主要介绍一些 WAN 和 LAN 的硬件。同时会介绍CSMA/CD 的以太网络协议，以及相关的硬件与MAC数据帧等

#### 2.2.1 广域网使用的设备

* 传统电话连接: 通过ppp协议

  早期网络大概都只能通过数据机加上电话线以及电脑的插孔, 然后通过Point-Point Protocol(PPP协议)配合拨号程序来取得网络IP参数,这样就能够上网了.不过这样的速度非常慢,而且当电话拨号后,就不能接电话了,因为PPP支持TCP/IP, NetBEUI, IPS/SPX等通讯协议,所以使用度非常广.

* 整合服务数字网络(Integrated Services Digital Network, ISDN)

* 非对称数字用路线路(Asymmetric Digital Subscriber Line, ADSL): 通过pppoe协议

  也是通过电话线来拨号后取得IP的一个方法,只不过这个方式使用的是电话的高频部分,和一般打电话的频率不同.因此你可以一边使用ADSL上网同时通过同一个电话好吗来打电话聊天.由于上传/下载的带宽不同,因此才称为非对称回路. ADSL同样使用数据机,只是他通过的是PPPoE(PPP over Ethernet)的方法, 将 PPP 模拟在以太网卡上,因此你的主机需要通过一张网卡来连接到数据机,并通过拨号程序来取得新的界面(ppp0)

* 电缆数据机(Cable modem)

  主要通过有线电视使用的线缆作为网络信号媒体.

#### 2.2.2 局域网使用的设备-以太网络

整个网络世界并非仅有以太网路哦这个硬件介质.

##### 以太网络的速度和标准

IEEE所制定的以太网络标准为 802.3 的<u>**IEEE 10BASE5**</u>, 这个标准主要的定义是: <u>10代表传输速度为 10Mbps, BASE 表示采用基带信号来进行传输, 至于5则是指每个网络节点之间最长可达500公尺</u>.

==数据传输的单位为每秒多少bit, 亦即是 M bits/second, Mbps的意思==.

> 当我们看到ISP所宣称的ADSL传输速度可以达到 下行/上行 2Mbps/128Kbps(**Kbits per second**)，这里的Kb指的不是bytes而是bits。所以2M/128K 在实际的文件大小传输速度上，最大理论传输为256KBps/16KBps(**KBytes per second**), 所以正常下载的速度约在每秒100~200KBytes 之间。所以一般bps还要除以8才是Bps,

五类线(常见的八股网线), 这种传输速度的以太网络就被称为Fast Ethernet(高速以太网络),速度是100Mbps. 至于常常听到的Gigabit网络速度 1000 Mbps 就是超高速以太网络(Gigabit Ethernet), 网线等级为 CAT 5e/CAT 6.

在以太网络世界中, 如果想要提升原有的fast ethernet 到 gigabit ethernet 的话, 除了网卡需要升级之外, 主机和主机之间的网线, 以及连接主机线路的集线器/交换机等, 都必须要升级到可以支持gigabit 速度等级的设备才行.

##### 以太网络的网线接头(跳接/平行)

跳线：一边为568A 一边为568B的接头时称为跳线，用在直接连接两部主机的网卡。

平行线：两边接头同为568A或568B时称为平行线，用在连接主机网卡与集线器之间的线材。

#### 2.2.3 以太网络的传输协议： CSMA/CD

以太网络的传输主要就是网卡到网卡之间的数据传输。==每张以太网卡出厂时，就会赋予一个独一无二的卡号，就是所谓的MAC（Media Access Control）==.以太网络的网卡之间数据是通过CSMA/CD来传输的。

中心点为集线器，各个主机都是连线到集线器，然后通过集线器的功能向所有主机发起连线的。

集线器是一种网络共享媒体. ==网络共享媒体在单一时间点内，仅能被一部主机所使用。==

CSMA/CD搭配上述的环境, 它的传输情况需要有以下的流程:

1. 监听媒体使用情况(Carrier Sense)：A主机要发送网络包前，先要对网络媒体进行监听，确认没人在用之后，才能发送出数据帧。
2. 多点传输(Multiple Access)： A主机所送出的数据会被集线器复制一份，然后传送给所有连接到此集线器的主机。
3. 碰撞检测(Collision Detection)：该数据帧具有检测能力, 如果其它主机比如B 电脑也刚好在同时间发送数据帧时, 那么A和B送出的数据会碰撞在一块, 此时数据帧就是损毁, 那么A和B 就会各自随机等待一个时间, 然后重新通过第一步再传送一次该数据帧.

<u>既然共享媒体只有一个主机可以使用，为何大家可以同时上网？</u>

由于标准的数据帧在网卡和其它以太网络媒体一次只能传输1500bytes, 因此我的 100MB的文件就得要拆成多个小的数据包, 然后一个个发送, 每个数据包发送之前都要经过CSMA/CD的机制. 所以, 这个集线器的使用权是大家抢着用的。即使只有一部主机在使用网络媒体时, 这部主机在发送每个数据包中间, 也都是要等待一段时间的(96 bit time)

#### 2.2.4 MAC的封装格式

CSMA/CD 传送出去的数据帧, 其实就是MAC. 数据帧上面有两个很重要的数据，就是目标和来源的网卡卡号，因此我们又简称网卡卡号为MAC而已. ==MAC是整个网络硬件上main传送数据的最小单位==.

**<u>在这个MAC 的传输过程中, 它仅在局域网内生效, 如果跨过不同的网段, 那么来源和目的硬件地址就会跟着改变了, 这是因为变成不同网卡之间的交流了, 所以卡号当然不同.</u>**

只要通过B（就是路由器）才将数据包送到另一个网段去的时候，数据帧内的网卡编号就会被改变。也就是 ==MAC 不能跨 router.==

* 为什么数据量最小要46 最大为 1500 bytes?

数据帧内的数据内容最小要46 Kbytes，因为要检测碰撞，数据帧数据总量要有64 Bytes，再去掉目的地址，来源地址，校验码后，就可以得到数据量最小要有46 Bytes，也就是说，如果你要传输的数据小于46 Bytes，系统会主动填上一些填充码，以补全至少46 Bytes的容量。

#### 2.2.5 MTU 最大传输单位

标准以太网络数据帧所能传送的数量最大可达1500 bytes，这个数值就被我们称为**MTU（Maximum Transmission Unit，最大传输单位）**.每种网络介质的MTU都不相同,因此有的时候在某些网络文章上你会看到 1492 bytes的MTU等等. 

IP==数据包最大可以达到==65535 bytes, 比MTU还大,所以 IP 数据包是可以进行拆解的,然后才能放到MAC中.等数据都传到目的地,再由目的地的主机将它组装回来.所以,如果MTU能够大一些的话, 那么IP数据包的拆解情况就会降低,数据包与数据包传送之间的等待时间也会减少,就能够增加网络频宽的使用.

不论你的网络媒体支持MTU到多大，你必须要考量到你的数据包需要传到目的地时，所需要经过的所有网络媒体，然后再来决定你的MTU设置。

#### 2.2.6 集线器、交换器和相关机制

##### 共不共享很重要，集线器还是交换机？

当一个很忙碌的网络在运行时，集线器（hub）这个网络共享媒体就可能会发生碰撞的情况，这是因为CSMA/CD的缘故。如果要避免这种数据包碰撞的情况，就使用非共享媒体的交换机即可。

交换机等级非常多，我们这里仅探讨支持OSI第二层的交换机。

==交换机和集线器最大的差异，在于交换机内有一个特别的主存，这个主存可以记录每个端口与其连接的PC的MAC的地址，==所以，当来自switch两端的PC要互传数据时，每个数据帧将直接通过交换机的主存数据而传送到目的主机上。所以switch不是共享媒体，且switch的每个端口都具有独立的频宽。

交换机已经克服了数据包碰撞的问题，因为他有个switch port对应MAC的功能，所以switch不是共享媒体。

##### 全双工/半双工（full-duplex, half-duplex）

八芯的网线实际上仅有两对被使用，一对是用在传送，另一对则是在接收。如果两端的PC同时支持全双工，那表示Input/Output均可达到10/100Mbps，亦即数据的传送与接收同时均可达到10/100Mbps的意思，使用全双工时不可以使用Hub，因为网线脚的关系，无法使用共享媒体达到全双工，如果switch支持全双工的模式，那么在switch两端的PC才能达到全双工。

### 2.3 TCP/IP的网络层相关数据包与资料

要有网络的话，必须要要有网络相关的硬件，而目前最常见的网络硬件介质是以太网络，包括网线、网卡、Hub/Switch等等。而以太网络上面的传输使用网卡卡号为基准的MAC数据帧，配合CSMA/CD的标准来传送数据帧，这就是硬件部分。

在软件部分，我们知道Internet其实就是TCP/IP 这个通讯协议的通称。Internet是由InterNIC所统一管理的，但其实它仅是负责分配Internet上面的IP以及提供相关的TCP/IP技术文件而已。

这小节我们来讲讲网络层的IP和路由。

#### 2.3.1 IP数据包的封装

目前IP有两种版本，一种是IPv4,一种是IPv6. IPv4记录的地址仅有32位。IPv6有128位。

IP数据包可以达到65535 bytes 这么大，在比MAC大的情况下，我们的操作系统会对IP进行拆分，至于IP数据包的表头如下。

每一行所占用的字符数为32 bits。

`Version`：声明这个IP数据包的版本，例如目前惯用的IPv4版本就在这个字段里声明

`IHL`：（Internet Header Length, IP表头的长度）

告知这个IP数据包表头长度，使用的单位应该是`word`，一个word为`4bytes`大小

`Type of Service`: 这个项目的内容为PPPDTRUU，表示这个IP数据包的服务类型。

举例来说，gigabit以太网络的种种相关规格可以让这个IP数据包加速且降低延迟，某些特殊的标志就是在这里声明的。

`Total Length`（总长度）:

指这个IP数据包的总容量，包括表头和内容（data）部分，最大可达65535 bytes

`Identification`（识别码）

我们前面提到IP数据包必须放在MAC帧中，不过，如果IP数据包太大的话，就得先要将IP再重组成较小的包然后再放到MAC帧中。反过来重组的时候就得要有个识别码以告知接收端这些小包是来自同一个IP数据包才行。

`Flags`（特殊标识）

这个地方的内容为0DM，其含义为：

D：如果为0表示可以分段，为1表示不可分段。

M：如果为0表示此IP为最后分段，为1表示非最后分段。

`Fragment Offset`（分段偏移）

表示目前这个IP分段在原始IP数据包中所占的位置。有点像是序列号，有这个序号才能将所有的小IP分段组合成为原本的IP数据包大小。通过Total Length, Identification, Flags 以及这个Fragment Offset就能够将小IP分段在接收端组合起来。

**`Time To Live`(TTL, 存活时间)**

==表示这个IP数据包的存活时间，范围为0~255。当这个`IP`数据包通过一个路由器时，TTL就会减1，当TTL为0时，这个包将会被直接丢弃。==要让IP数据包通过255个路由器，还挺难的。

`Protocol Number`（协议代码）

来自传输层和网络层本身的其他数据都是放在IP数据包当中的，我们可以在IP表头记载这个IP数据包内的资料是什么，在这个字段就是记载每种数据包的内容。在这个字段记载的代码和相关的数据包协议名称如下所示：

| IP内的号码 |          数据包协议名称（全名）           |
| :--------: | :---------------------------------------: |
|     1      | ICMP (Internet Control Message Protocol)  |
|     2      | IGMP (Internet Group Management Protocol) |
|     3      |     GGP (Gateway-to-Gateway Protocol)     |
|     4      |        IP (IP in IP encapsulation)        |
|     6      |    TCP (Transmission Control Protocol)    |
|     8      |      EGP (Exterior Gateway Protocol)      |
|     17     |       UDP (User Datagram Protocol)        |

比较常见到的还是TCP， UDP，ICMP。

`Header Checksum`（表头校验码）

用来检查这个IP表头的错误校验之用。

`Source Address`

来源的IP地址，从这里也可以知道IP是32位字符。

`Destination Address`

目标IP地址

`Options`（其他参数）

这个是额外的功能，提供包括安全处理机制、路由记录、时间戳、严格与宽松的来源路由等。

`Padding`（补齐项目）

由于Options的内容不一定有多大，但是我们知道IP每个数据都必须要是32 bits，所以，如果Options的数据不足32 bits时，则由padding主动补齐。

只要知道IP表头里面有：`TTL`，`Protocol`，来源地址和目标地址也就够了。而这个IP表头的来源与目标IP，以及那个判断通过多少路由器的TTL，就能了解到这个IP将被如何传送到目的地端。

#### 2.3.2 IP地址的组成和分级

将32 bits的IP分成4小段，每段含有8个bits（==那么每段可以表示的范围就是0\~255==, 2的8次方为256），将8个bits计算成十进位，并且每段中间以小数点隔开，那就成了目前大家所熟悉的IP的书写模样。所以IP最小可以由0.0.0.0一直到255.255.255.255。==这一串数字中，可以分为两个部分，主要分为Net_ID（网段号码）和Host_ID(主机号码)两部分==。我们先以192.168.0.0~192.168.0.255这个Class C的网段作说明：

<u>同一个网段的定义： 在同一个物理网段内，主机的IP具有相同的Net\_ID,并且具有独特的Host\_ID</u>

物理网段指的是当所有的主机都是使用同一个网络媒体串在一起，这个时候这些主机在实体装置上其实是连线在一起的，那么就可以称为这些主机在同一个物理网段内了。同一个物理网段内，可以依据不同的IP设置，而设置成多个**IP网段**。

##### IP在同一网段的意义

* Net_ID 与 Host_ID 的限制：

	在同一个网段内，Net_ID是不变的，而Host_ID则是不可重复。此外，==Host_ID不可同时为0也不可同时为1，全为0表示网段的地址，全为1表示广播的地址（Broadcast IP）。==所以一个网段中可用来设定主机IP的数量为2^Host_ID的位数-2

* 在同一网段内通过IP广播传播数据

* 设定不同网段在相同物理网段的情况

* 网域的大小

在同物理网段的主机如果设置相同的网段IP，则这些主机都可以通过CSMA/CD的功能直接在网段内用广播进行网络连接，也就是直接网卡对网卡传输数据（通过MAC数据帧）

##### IP的分级

```shell
以二進位說明 Network 第一個數字的定義：
Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的開頭是 0
          |--net--|---------host------------|
Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的開頭是 10
          |------net-------|------host------|
Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的開頭是 110
          |-----------net-----------|-host--|
Class D : 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的開頭是 1110
Class E : 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的開頭是 1111

五種分級在十進位的表示：
Class A :   0.xx.xx.xx ~ 127.xx.xx.xx
Class B : 128.xx.xx.xx ~ 191.xx.xx.xx
Class C : 192.xx.xx.xx ~ 223.xx.xx.xx
Class D : 224.xx.xx.xx ~ 239.xx.xx.xx
Class E : 240.xx.xx.xx ~ 255.xx.xx.xx
```



Class D 是用来作为广播的特殊功能之用，至于Class E则是保留没有使用的网段。

#### 2.3.3 IP的种类与取得方式

私有IP也分别在A、B、C三个Class中各保留一段作为私有IP网段

* Class A: 10.0.0.0    ~  10.255.255.255

* Class B: 172.16.0.0  ~  172.31.255.255

* Class C: 192.168.0.0  ~  192.168.255.255

这三段Class的IP是预留使用的，所以并不能直接作为Internet上面的连接使用。这三个IP网段就只作为内部私有网段的IP沟通之用。简单的说，他有底下的几个限制：

1. 私有IP的路由信息不能对外散播（只能存在内部网络）
2. 使用私有IP作为来源或目的地址的数据包，不能通过Internet来传输
3. 关于私有IP的参考记录（如DNS），只能限于内网使用

如果想要将这些私有IP送上Internet， 设定一个简单的防火墙加上NAT（Network Address Transfer）服务，你就可以通过IP伪装来使你的私有IP的电脑连上Internet。

##### 特殊的loopback IP网段

还有一个奇怪的Class A 的网址，那就是lo 这个奇怪的网段。这个lo 的网络是当初被用来作为测试操作系统内部循环所用的一个网址，同时也能够提供给系统内部原本就需要使用网络接口的服务（daemon）所使用。

简单的说，如果你没有安装网卡在机器上，但是你又希望可以测试一下在你的机器上设置的服务器环境到底可不可以顺利运行，就利用这个内部loop网络。

这个网段在`127.0.0.0/8` 这个Class A，而且默认的主机(localhost)IP是`127.0.0.1`.所以， 当你启动了你的www服务器，然后在你的主机的X-Window上面执行http://localhost 就可以直接看到你的主页，而且不需要安装网卡。

此外， 你的内部使用的mail怎么运送邮件：例如你的主机系统如何mail给root，也就是使用这个内部loop。要测试TCP/IP数据包状态是否正常，也可以用这个。（所以哪天有人问你，你的主机上面没有网卡，那么你可以测试你的WWW服务器设置是否正确吗？ 这个时候可以回答：可以， 使用127.0.0.1这个地址）

##### IP的取得方式

谈完了IP的种类与等级还有相关的子网概念后，接下来我们得来了解一下，主机的IP是如何设置的。

直接手动设置

​		可以直接向网关询问可用的IP相关参数，然后直接编辑配置文件来设置网络。常见于校园网络的环境中，以及向ISP申请固定IP的连线环境

通过拨号取得

​		向你的ISP申请注册，取得账号密码后，直接拨号到ISP，你的ISP会通过他们自己的设置，让你的操作系统取得正确的网络参数。此时你并不需要手动去编辑和设定相关的网络参数。

自动取得网络参数（DHCP）

​		在局域网内会有一部主机负责管理所有的电脑的网络参数，你的网络启动时就会主动向该服务器要求IP参数，若取得网络相关参数后，你的主机就能够自行设置好所有服务器给你的网络参数了。最常用于企业内部，IP分享器后端，校园网络和宿舍环境，以及缆线宽频等连线方式。

#### 2.3.4 Netmask, 子网与CIDR（Classless Interdomain Routing）

我们前面谈到IP是有等级的，而设置在一般电脑系统上的则是Class A, B, C。

如果我们设置一个局域网，使用的是Class A, 那么我们很容易就会想到，哪有这么多电脑可以设置在同一个Class A的网段内（256\*256\*256-2=16777214）？而且，假设真有这么多电脑好了，回想一下CSMA/CD吧，你的网络恐怕会一直非常停顿，因为你要接到一千多万台电脑对你的广播。

此外，分为Class的IP等级，是为了管理方面的考量，事实上，我们不可能将一个Class A仅划定为一个局域网。

如何将网段切分的更细？这样就可以分出更多段的局域网给大家设置了。

前面我们提到IP这个32-bits的数值中分为网段号码和主机号码，其中Class C的网段号码占了24位，其实我们还可以将这样的网段切的更细，==就是让第一个主机ID被拿来作为网段ID==，<u>所以整个网段ID就有25 bits，而主机ID则减少为7 bits</u>。这样的情况下，==原来的一个Class C的网段就可以被切分为两个较小的网段==，而每个子网段就有==256/2 - 2=126==个可用IP了

##### Netmask，或称为 Subnet mask（子网掩码）

用什么参数来达成子网络切分呢？ 那就是用Netmask。

以192.168.0.0~192.168.0.255这个网段为范例

既然Net_ID是不可变的，那就假设他所占据的bits都被用光了（全是1），而Host_ID是可变的，就将他想成是保留着（全部为0），所以 Netmask就表示为： 255.255.255.0

==在数值上，位于Net_ID的为1 而Host_ID为0==.

Class A, B, C 三个等级的Netmask 表示方式：

Class A: 255.0.0.0

Class B: 255.255.0.0

Class C: 255.255.255.0

==当Host_ID全部是0以及全部是1的时候该IP是不可使用的，因为Host_ID全为0的时候表示该网段的Network，全为1的时候表示该网段最后一个IP，也称为Broadcast==，所以，在192.168.0.0~192.168.0.255 这个IP网段里面的相关网络参数有：

Netmask:  255.255.255.0       # 网段定义中，最重要的参数

Network: 192.168.0.0		# 第一个IP

Broadcast:  192.168.0.255		# 最后一个IP

可用来设置成为主机的IP数： 192.168.0.1 ~ 192.168.0.254

##### 子网络切分

以192.168.0.0 ~ 192.168.0.255这个情况为例，如何再细分为两个子网呢？ 我们已经知道Host_ID可以拿来当做Net_ID, 那么Net_ID使用了25 bits时， 就会如下所示：

```shell
# 原本的C Class的Net_ID 与 Host_ID 的分别
11000000.10101000.00000000.00000000      Network:   192.168.0.0
11000000.10101000.00000000.11111111      Broadcast: 192.168.0.255
|----------Net_ID---------|-host--|

# 切成两个子网之后的Net_ID 和 Host_ID
11000000.10101000.00000000.0 0000000  多了一個 Net_ID 了, 為 0 (第一個子網)
11000000.10101000.00000000.1 0000000  多了一個 Net_ID 了, 為 1 (第二個子網)
|----------Net_ID-----------|-host--|

第一個子網路
Network:   11000000.10101000.00000000.0 0000000   192.168.0.0
Broadcast: 11000000.10101000.00000000.0 1111111   192.168.0.127
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128

第二個子網路
Network:   11000000.10101000.00000000.1 0000000   192.168.0.128
Broadcast: 11000000.10101000.00000000.1 1111111   192.168.0.255
           |----------Net_ID-----------|-host-|
Netmask:   11111111.11111111.11111111.1 0000000   255.255.255.128
```



试着计算出172.16.0.0， Net_ID 占用23个字符时，这个网段的Netmask，Network，Broadcast等参数

##### 无层级IP： CIDR（Classless Interdomain Routing）

一般来说，如果我们知道了Network和Netmask之后，就可以定义出该网段的所有IP了，因为由Netmask就可以推算出Broadcast的IP。因此，我们常常会以Network以及Netmask来表示一个网段，例如这样的写法：

```shell
Network/Netmask
192.168.0.0/255.255.255.0
192.168.0.0/24   # 因为 Net_I 共有24个 bits
```

另外，既然Netmask里面的Net_ID都是1， 那么Class C共有24 bits的Net_ID, 所以啦，就有类似192.168.0.0/24这种写法。这就是一般网段的表示方法。

事实上，由于网络细分的情况太严重，为了担心路由信息过于庞大而导致网络性能不佳，因此，某些特殊情况下，我们反而是将Net_ID借用来作为Host_ID的情况。这样就能将多个网段写成一个。举例来说，我们将256个Class C的私有IP（192.168.0.0 ~ 192.168.255.255）写成一个路由信息的话，那么这个网段的写法就变成 192.168.0.0/16, 反而将192 开头的Class C变成Class B的样子了。这种打破原本IP 代表等级的方式（通过Netmask的规范）就被称为==无等级域间路由（CIDR）==

那个Network/Netmask的写法，通常就是CIDR的写法。你也要知道如何通过Netmask去计算出Network， Broadcast及可用的IP等。

#### 2.3.5 路由概念

我们知道在同一个局域网里面，可以通过IP广播的方式来达到数据传输的目的。但如果是非局域网内的数据呢，这时候就得要通过路由器的帮忙了。

> 例题： 请问 192.168.10.100/25 与 192.168.10.200/25
>
> 答：
>
> ​		经过计算，192.168.10.100的Network为192.168.10.0，但是 192.168.10.200的network为192.168.10.128，由于Net_ID不同，所以不再同一个网段。

当主机想要传送数据时，他主要参考的是路由表。每部主机都有自己的路由表。

默认情况下，PC01 要如何将数据传送到PC02

1. 查询IP数据包的目标IP地址：

	当PC01有IP数据包需要传送时，主机会查询IP数据包表头的目标IP地址

2. 查询是否位于本机所在的网段的路由设置：

	PC01主机会分析自己的路由表，当发现目标IP与本机IP的Net_ID相同时（同一网段），则PC01会直接通过局域网功能，将数据直接传送给目的地主机。

3. 查询默认路由（default gateway）

	如果两机并非同一网段，PC01会分析路由表中是否有其他相符合的路由设置，如果没有的话，就直接将该IP数据包送到默认路由器（default gateway)上。

4. 送出数据包到gateway后，不理会数据包流向

	当IP由PC01送给路由器后，PC01就不会理会接下来的工作。而Server A接到这个数据包后，会依据上述的流程，也分析自己的路由信息，然后继续传输到正确的目的地主机上。

> Gateway/Router: 网关/路由器的功能就是在负责不同网段之间的数据包转发，由于路由器具有转发的功能，并且具有管理路由的能力，所以可以将来自不同网段之间的数据包进行转发的功能。此外，你的主机和你的主机设定的Gateway必定是在同一个网段内。

每一部主机里面都会存在着一个路由表，数据的传递将依据这个路由表进行传送。而一旦数据包经由路由表的规则传送出去后，那么主机本身就已经不再管数据包的流向了，因为该数据包的流向僵尸下一个主机（也就是Router）来进行传送，而Router在传送时，也是根据Router自己的路由表来判断该数据包应该经由哪里传送出去的。

Internet上面的路由并不是静态的，他可以随时因为环境的变化而修改每个数据包的传送方向。

#### 2.3.6 观察主机路由： route

既然路由是这么重要，而且==路由一旦配置错误，将会造成某些数据包完全无法正确地送出去==。==每一部主机都有自己的路由表==， 管家路由表的指令很简单，就是route。

```shell
[root@www ~]# route [-n]
选项与参数：
-n: 将主机名称以IP的方式显示

[root@www ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref  Use Iface
192.168.0.0     *               255.255.255.0   U     0      0      0 eth0
127.0.0.0       *               255.0.0.0       U     0      0      0 lo
default         192.168.0.254   0.0.0.0         UG    0      0      0 eth0

Destination： 就是Network的意思
Gateway： 就是该界面的Gateway的IP，如果是0.0.0.0表示不需要额外的IP
Genmask:  就是Netmask,与Destination组合成为一部主机或网段
Flags:	  共有多个flag可以来表示该网段或主机代表的含义：
		  U： 代表该路由可用
		  G： 代表该网段需要经由 Gateway 来帮忙转发
		  H： 代表该行路由为一部主机，而非一整个网段
Iface：   就是Interface的意思
```

由于PC 01为192.168.0.0/24这个网段，所以主机已经建立了这个网段的路由了，就是192.168.0.0那一行。当下达route时，屏幕上说明了这部机器上有三个路由规则，第一列为==目的地的网段==。例如192.168.0.0就是一个网段。最后一列显示的是 ==要去到这个目的地要使用哪个网卡==， 如果网关为\*， 就会直接以最后的网卡传送出去，而不通过网关。

万一我们要传送的数据包目的IP不在路由规则里面，那么就会将数据包传送到default那个路由规则去。所以，几乎每部主机都会有一个default gateway来帮他们负责所有非局域网内的数据包转发。

#### 2.3.7 IP与MAC：链路层的ARP和RARP协议

在传送数据的是以太网络，以太网络主要是用网卡卡号（MAC），那么IP和MAC一定有一个关联性存在。就是ARP（Address Resolution Protocol, 地址解析协议),和RARP（反向地址解析协议）

当我们想要了解某个IP其实是设置在某张以太网卡上时，我们主机会对整个局域网发出ARP数据包，对方收到ARP数据包后会回传他们的MAC给我们，我们的主机就会知道对方所在的网卡，接下来就能够开始传递数据。当使用ARP洗衣取得目标IP和他的网卡卡号后，就会将该记录写入我们主机的ARP table中（主存内的数据）记录20分钟

如何获取本机的ARP 表格内的IP/MAC对应数据：

```shell
[root@www ~]# arp -[nd] hostname
[root@www ~]# arp -s hostname(IP) Hardware_address
选项与参数：
-n ：将主机名称以IP的形式展示
-d ：将hostname的 hardware_address由ARP table中删掉
-s ：设置某个IP或hostname的MAC到ARP table中
```

当你发送ARP数据包取得的IP/MAC对应，这个记录的ARP table是动态的信息（一般保留20分钟），它会随时随着你的网络里面电脑的IP变化而变化。如果你有特殊需求，也可以利用`arp -s`这个选项来定义静态的ARP对应。

#### 2.3.8 ICMP协议

ICMP的全名是 Internet Control Message Protocol, 网际网络信息控制协议。ICMP是一个错误检测与回传的机制，最大的功能就是可以确保我们网络的连线状态和连线的正确性。ICMP也是网络层重要的数据包之一，不过，这个数据包并非单独存在，而是纳入到IP的数据包中，也就是说，ICMP同样是通过IP数据包来进行数据传送的。

ICMP有相当多的类别可以检测和回传，底下是比较常见的类别

| 类别代号 |        类别名称与意义        |
| :------: | :--------------------------: |
|    0     | Echo Reply(代表一个回应信息) |
|    8     |  Echo Request(请求回应信息)  |

我们如何利用ICMP来检验网络的状态呢？最简单的指令就是ping和traceroute了，这两个指令可以通过ICMP数据包的辅助来确认和回传网络主机的状态。在设置防火墙的时候，我们最容易忽略的就是这个ICMP数据包了，因为只会记住TCP/UDP而已，事实上，ICMP数据包可以帮助连线状态的回传，除了上述的8可以考虑关闭意外，基本上，ICMP数据包也不应该全部都挡掉。

### 2.4 TCP/IP 传输层相关数据包与资料

网络层的IP数据包只负责将数据送到正确的目标主机去，但是这个数据包会不会被接受，或者是有没有被正确的接收，那就是传输层的任务之一。

传输层有两个重点，一个是连接导向的TCP数据包，一个是非连接导向的UDP数据包。

#### 2.4.1 可靠连接的TCP协议

在前面的OSI七层协议中，在网络层的IP之上则是传输层，而传输层的数据打包成什么？最常见的就是就是TCP数据包了。这个TCP数据包必须要能够放到IP的数据包中。

TCP数据包的表头中 Source Port, Destination Port, Code算是比较重要的项目。

* Source Port & Destination Port(来源端口 & 目标端口)

	我们知道IP数据包的传输主要是藉由IP地址连接两端，但是到底这个连接的通道是连接到哪里去呢？ 就是连接到端口上的。

* Sequence Number(数据包序号)（32 bits）

	由于TCP数据包必须要带入IP数据包中，所以如果TCP数据太大时（大于IP数据包的最大容量），就得要进行分段。这个Sequence Number 就是记录每个数据包的序号，可以让接收端重新将TCP的数据组合起来

* Acknowledge Number（回应序号）（32 bits）

	为了确认主机端确实有收到我们client端所送出的数据包资料，我们client端当然希望能够收到主机方面的回应，那就是这个Acknowledge Number的用途了。当client端收到这个确认码时，就能够确定之前传递的数据包已经被正确的收下了。

* Data Offset(数据偏移)

* Reserved

* Code（Control Flag, 控制标识符）

	当我们在进行网络连接的时候，必须要说明这个连接的状态，好让接收端了解这个数据包的主要动作。这个字段共有6个bits，分别代表6个控制码，若为1则为启动：

	* URG（Urgent）：若为1则代表该数据包为紧急数据包，接收端应该要紧急处理，且Urgent Pointer字段也会被启用
	* ==ACK（Acknowledge）==：若为1代表这个数据包为回应数据包，则与上面提到的 Acknowledge Number 有关
	* PSH（Push function）：若为1时，代表要求对方立即传送缓冲区内的其他对应数据包，而无需等待缓冲区满了才送。
	* RST（Reset）：如果RST为1的时候，表示连接会被马上结束，而无需等待终止确认手续。这个是强制结束的连接，且发送端已经断线。
	* ==SYN（Synchronous）==：若为1，表示发送端希望双方建立同步处理，也就是要求建立连接。通常带有SYN标志的数据包表示主动要连接到对方的意思。
	* FIN（Finish）：若为1，表示传输结束，所以通知对方数据传完，是否同意断开连接，知识发送者还在等待对方的回应而已。

	未来在谈到防火墙的时候，你才会比较清楚为啥每个TCP数据包都有所谓的状态条件，那就是因为连接方向的不同导致的。

* Window（滑动窗口）

	主要是用来控制数据包的流量的，可以告知对方目前本身有的缓冲区容量，还可以接收数据包。当Window=0时，代表缓冲区已经塞满，所以应该要暂停传输数据。Window的单位是byte

* Checksum（确认检查码）

	当数据要由发送端送出前，会进行一个校验的动作，并将该动作的校验值标注在这个字段上；而接受者收到这个数据包之后，会再次对数据包进行验证，并且比对原发送的Checksum值是否相等，如果相等就接受，如果不相等就假设该数据包已经损毁，进而要求对方重新发送此数据包

* Urgent Pointer（紧急资料）

	此字段是在Code字段内的URG=1时才会产生作用。可以告知紧急数据所在的位置。

* Options（任意资料）

	目前这个字段仅用于表示接收端可以接收的最大数据段容量，如果此字段不使用，表示可以使用任意数据段的大小。

* Padding（补足列）

	如同IP数据包需要有固定的32bits表头一样，Options由于字段为非固定，所以也需要Padding字段来补齐。同样也是32-bits的整数。

##### 通讯端口

由于是16-bits，因此目标和来源端口最大可达65535号。端口的用处：网络是双向的，服务器和用户端要达成连接的话，两边应该要有一个对应的端口来达成连接通道，好让数据可以通过这个通道来进行传输。

端口的打开：通过程序的执行。

##### 特权端口

网络既然是双向的，一定有一个发起端。Internet上面已经有很多规范好的固定端口，这些端口号通常小于1024，且是提供给许多知名的网络服务软件用的。在Linux环境下，各网络服务与端口号的对应默认设置写在`/etc/services`文件内。

底下列出几个常见的端口号和网络服务对应：

| 连接端口 |                    服务名称和内容                    |
| :------: | :--------------------------------------------------: |
|    20    |    FTP-data，文件传输协议所使用的主动数据传输端口    |
|    21    |             FTP，文件传输协议的命令端口              |
|    22    |            SSH，较为安全的远程连接服务器             |
|  ==23==  |         ==Telnet，早期的远程连接服务器软件==         |
|    25    |  SMTP，简单邮件传输协议，用在作为mail server的端口   |
|  ==53==  |         ==DNS，用来作为域名解析服务器端口==          |
|    80    |                 WWW，万维网服务端口                  |
| ==110==  | ==POP3，邮件接收协议，办公室用的收信软件都是通过他== |
|   443    |           https，有安全加密机制的WWW服务器           |

小于1024以下的端口要启动时，启动者身份必须是root才行，所以才叫特权端口。如果是client端，由于client端都是主动向server端要资料，所以client端的端口号就随机取用一个大于1024且没有在使用的端口号

##### Socket Pair

由于网路是双向的，要达成连接的话要服务器与用户端均提供IP和端口才行。因此，我们常常将这个成对的数据叫做Socket Pair.

* 来源IP + 来源端口
* 目的IP + 目的端口

由于IP与端口常常连在一起说明，因此网络地址常常使用`IP:port`来说明。

#### 2.4.2 TCP的三次握手

TCP被称为可靠的连接数据包，主要是通过很多机制来达成的。其中最重要的就是三次握手功能。如何藉由TCP的表头来确认这个数据包有实际被对方接收，并进一步和对方主机达成连接？

在上面的数据包连接模式中，在建立连接之前都必须要通过三个确认动作，所以这种连接方式也就被称为==三次握手==。

* **A：数据包发起**

	当用户端想要向服务端连接时，就必须要发送一个要求连接的数据包，此时客户端必须随机取用一个大于1024以上的端口来作为程序传输的接口。然后在TCP的表头中，必须要带有SYN的主动连接（SYN=1），并且记下发送出连接数据包给服务器端的序号（Sequence number = 10001）

* **B：数据包接收和确认数据包传送**

	当服务器接收到这个数据包，并且确定要接受这个数据包后，就会开始制作一个同时带有SYN=1，ACK=1的数据包，其中那个acknowledge的号码是要给客户端确认用的，所以该数字会比A步骤里面的Sequence号码多一号（ack = 100001 + 1 = 10002）,服务器端也必须要确认客户端确实可以接收我们的数据包才行，所以也会发出一个Sequence（seq=20001）给客户端，并且开始等待客户端给我们服务器端的回应。

* **C：回传确认数据包**

	当客户端收到来自服务器端的ACK 数字后（10002）就能够确认之前那个请求数据包被正确接受了，接下来如果客户端也同意和服务端建立连线时，就会再次发送一个确认数据包（ACK=1）给服务器，亦即是acknowledge = 20001 + 1 = 20002

* **D：取得最后确认**

	如果一切顺利，在服务端收到带有ACK=1且ack=20002序号的数据包后，就能建立起这次的连接了。

也就是说，你必须要了解 ==网络是双向的==这个事实。所以不论是服务器端还是客户端，都必须要通过一次SYN和ACK来建立连接，所以总共会进行三次握手，在设置防火墙或者追踪网络连接的问题时，这个双向的概念最容易被忽略。

#### 2.4.3 非连接导向的UDP协议

UDP的全名是：User Datagram Protocol, 用户数据报协议。UDP和TCP不一样，UDP不提供可靠的传输模式，因为它不是连接导向的一个机制，这是因为在UDP的传输过程中，接收端在接受到数据包之后，不会回复回应数据包（ACK）给发送端，所以数据包并没有像TCP数据包有较为严密的检查机制。

同时UDP比较适合需要即时反馈的一些数据流，例如影像即时传输软件等，就可以使用这类的数据包传输。也就是说，UDP传输协议并不考虑连接要求、连接终止和流量控制等特性，所以使用的时机是当数据的正确性不很重要的情况，例如网络摄像头。

另外，很多的软件其实同时提供TCP和UDP的传输协议，举例来说，查询主机名称的DNS服务就同时提供了UDP/TCP协议。由于UDP较为快速，所以我们客户端可以先使用UDP来和服务器连线。但是当使用UDP连线却还是无法取得正确的数据时，便转为较为可靠的TCP传输协议来进行数据的传输。这样可以同时兼顾快速和可靠的传输。

#### 2.4.4 网络防火墙和OSI七层协议

由上面的说明中，我们知道数据的传输其实就是数据包的发送和接受的动作，并且不同的数据包上面都有不一样的表头。此外，数据包上通常都会有四个基本的信息，那就是socket pair里面提到的来源和目的IP以及来源和目的端的端口。如果是可靠性连接的TCP数据包，还包含Control Flag里面的SYN/ACK等重要信息。

数据包过滤式的网络防火墙可以抵挡掉一些可能有问题的数据包，Linux系统上面是怎么挡掉数据包的呢？既然数据包的表头上面已经有这么多的重要信息，那么我就利用一些防火墙机制和软件来进行数据包表头分析，并设置分析的规则，当发现某些特定的IP、特定데端口或者是特定的数据包信息（SYN/ACK等等），那么就将该数据包丢弃，这就是最基本的防火墙原理。

举例来说，大家都知道Telnet 这个服务器挺危险，而Telnet使用的端口号是23，所以，当我们使用软件去分析要送进我们主机的数据包时，只要发现该数据包的目的端口是我们主机的port 23，就将该数据包丢掉，这就是防火墙最基本的案例。如果以OSI 七层协议来说，每一层可以抵挡的信息有：

* **第二层：可以针对来源和目标的MAC 进行拦截**
* **第三层：主要针对来源和目标的IP，以及ICMP的类别进行拦截**
* **第四层：针对TCP/UDP 的端口进行拦截，也可以针对TCP的状态来处理。**



### 2.5 连上 Internet前的准备事项

#### 2.5.1 用IP上网？主机名称上网？DNS系统？

将主机名称和他的IP对应起来，未来要连接到该电脑时，只要知道该电脑的主机名称就好了，因为IP已经对应到主机名称了。

这个主机名称（Hostname）对应IP的系统，就是Domain Name System(DNS)，也就是说，DNS这个服务的最大功能就是在进行主机名称和该主机IP的对应的一项协议。DNS在网络环境中是经常被使用到的一个协议。

我的电脑必须要向NDS服务器查询Hostname对应的IP信息，那么那部DNS主机的IP就必须要在我的电脑里设置好才行。在Linux里，DNS主机的IP设置就是在`/etc/resolv.conf`这个文件里面。

#### 2.5.2 一组可以连上Internet的必要网络参数

从上面的说明中，我们知道一部主机要能够使用网络，必须要有IP，而IP的配置文件中，就必须要有IP，Network，Broadcast，Netmask等参数，此外，还需要考虑到路由里面的Default Gateway才能够正确的将非同网段的数据包传送出去。另外，考虑到主机名称和IP的对应，所以你还必须要给予系统一个DNS服务器的IP才行。所以，一组合理的网络设置需要：

* IP
* Netmask
* Network
* Broadcast
* Gateway
* DNS

其中，==由于Network和Broadcast可以由`IP/Netmask`的计算得到，因此需要你设置的关于PC端的网络参数，主要就是IP，Netmask，Default Gateway，DNS这四个就是了。==

以192.168.1.0/24这个C类网段为例的话，你就必须要设置好如下参数：

IP： 192.168.1.1 ~ 192.168.1.254 共254个IP

Netmask: 255.255.255.0

Network: 192.168.1.0

Broadcast: 192.168.1.255